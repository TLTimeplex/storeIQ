function b(s,e){var t,r,n,i;return{register:{autoSaveInterval:((t=s.register)==null?void 0:t.autoSaveInterval)||e.register.autoSaveInterval},webStorageThreshold:s.webStorageThreshold||e.webStorageThreshold,debug:s.debug||e.debug,shutter:{enabled:((r=s.shutter)==null?void 0:r.enabled)||e.shutter.enabled,interval:((n=s.shutter)==null?void 0:n.interval)||e.shutter.interval,timeout:((i=s.shutter)==null?void 0:i.timeout)||e.shutter.timeout}}}var I={register:{autoSaveInterval:1e3},debug:!1,webStorageThreshold:1e3,shutter:{enabled:!0,interval:100,timeout:150}};var c={_SIQ_sanityCheck_EntryOptions:{isEnabled:!0,expires:{isEnabled:!0,checkPositiv:!0,checkExpired:!0}}};function f(s){if(!(!c._SIQ_sanityCheck_EntryOptions.isEnabled||s===void 0)&&s.expires!==void 0&&c._SIQ_sanityCheck_EntryOptions.expires.isEnabled){if(typeof s.expires!="number")throw new Error("SanityC: The expires option must be a number");if(c._SIQ_sanityCheck_EntryOptions.expires.checkExpired&&s.expires<Date.now())throw new Error("SanityC: The expires option must be in the future");if(c._SIQ_sanityCheck_EntryOptions.expires.checkPositiv&&s.expires<0)throw new Error("SanityC: The expires option must be a positive number")}}function Q(s,e,t,r){return new Promise((n,i)=>{try{f(r),s.MemoryMap.set(e,t);var o="l";t==null||(t instanceof Object?o="i":typeof t=="string"&&t.length>s.Settings.webStorageThreshold&&(o="i")),r!==void 0&&r.sessional!==void 0&&r.sessional&&o==="l"&&(o="s");let u={key:e,location:o,value:t,callback:k=>{k||s.ErrorHandler.error(new Error("Failed to store the value")),n()}};s.Queue.addOrder(u);var a={location:o};r!==void 0&&(r.expires!==void 0&&(a.expires=r.expires),r.sessional!==void 0&&r.sessional&&(a.session=s.SessionID)),s.Register.set(e,a)}catch(u){s.ErrorHandler.error(u),n()}})}var d=class{constructor(){this.listeners=[]}addListener(e){this.listeners.push(e)}removeListener(e){this.listeners=this.listeners.filter(t=>t!==e)}removeAllListener(){this.listeners=[]}error(e){this.listeners.forEach(t=>t(e))}};function v(s,e){localStorage.setItem(s,JSON.stringify(e))}function y(s){let e=localStorage.getItem(s);return e?JSON.parse(e):null}function w(s){localStorage.removeItem(s)}function D(s,e){sessionStorage.setItem(s,JSON.stringify(e))}function x(s){let e=sessionStorage.getItem(s);return e?JSON.parse(e):null}function E(s){sessionStorage.removeItem(s)}var g=class{constructor(){this.items=[]}enqueue(e){this.items.push(e)}dequeue(){return this.items.shift()}clear(){this.items=[]}getAll(){return[...this.items]}length(){return this.items.length}isEmpty(){return this.items.length===0}};var m=class{constructor(e,t,r){this.blocked=!0;this.enabled=!1;this.running=!1;this.task=null;this.errOut=t,this.settings=e,this.indexedDB=r,this.queue=new g}async init(){}async processQueue(){try{for(this.running=!0;this.enabled;){let e=new Date().getTime(),t=new Date().getTime()+this.settings.shutter.interval,r=t+this.settings.shutter.timeout;this.settings.debug&&console.log("Async Queue: start:".concat(e,", end:").concat(t,", next:").concat(r)),this.process(t),await new Promise(n=>setTimeout(n,r-new Date().getTime()))}this.settings.debug&&console.log("Async Queue: Stopped by request.")}catch(e){this.errOut.error(e),this.settings.debug&&console.log("Async Queue: Stopped by error.")}finally{this.running=!1}}async process(e){var t,r,n;if(!(this.blocked||!this.enabled)&&!this.queue.isEmpty()&&(this.indexedDB===null&&await this.init(),!!((t=this.indexedDB)!=null&&t.isOpen()))){for(this.blocked=!0;new Date().getTime()<e;){let i=this.queue.dequeue();if(i==null)break;switch(i==null?void 0:i.location){case"i":await this.indexedDB.set(i.key,i.value);break;case"l":v(i.key,i.value);break;case"s":D(i.key,i.value);break;default:(r=i.callback)==null||r.call(i,!1),this.errOut.error(new Error("Invalid location"));break}(n=i.callback)==null||n.call(i,!0)}this.blocked=!1}}start(){if(this.running)return this.errOut.error(new Error("Async Queue is already running"));if(this.enabled)return this.errOut.error(new Error("Async Queue is already enabled"));if(this.task!==null)return this.errOut.error(new Error("Async Queue has already been initialized"));this.enabled=!0,this.blocked=!1,this.task=this.processQueue()}async stop(){if(!this.enabled)return this.errOut.error(new Error("Async Queue is not enabled"));if(this.task===null)return this.errOut.error(new Error("Async Queue has not been initialized"));this.enabled=!1,await this.task,this.blocked=!0,this.task=null}isRunning(){return this.running}addOrder(e){this.queue.enqueue(e)}};var l=class{constructor(e,t){this.db=null;this.storeName=t,this.dbName="SIQ_"+e}async get(e){return new Promise((t,r)=>{if(this.db){let o=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).get(e);o.onsuccess=()=>{t(o.result)},o.onerror=()=>{r(o.error)}}else r("Database not open")})}async set(e,t){return new Promise((r,n)=>{if(this.db){let a=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).put(t,e);a.onsuccess=()=>{r()},a.onerror=()=>{n(a.error)}}else n("Database not open")})}async delete(e){return new Promise((t,r)=>{if(this.db){let o=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).delete(e);o.onsuccess=()=>{t()},o.onerror=()=>{r(o.error)}}else r("Database not open")})}async clear(){return new Promise((e,t)=>{if(this.db){let i=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).clear();i.onsuccess=()=>{e()},i.onerror=()=>{t(i.error)}}else t("Database not open")})}async keys(){return new Promise((e,t)=>{if(this.db){let i=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAllKeys();i.onsuccess=()=>{e(i.result)},i.onerror=()=>{t(i.error)}}else t("Database not open")})}async values(){return new Promise((e,t)=>{if(this.db){let i=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAll();i.onsuccess=()=>{e(i.result)},i.onerror=()=>{t(i.error)}}else t("Database not open")})}async entries(){return new Promise((e,t)=>{if(this.db){let i=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAll();i.onsuccess=()=>{e(i.result)},i.onerror=()=>{t(i.error)}}else t("Database not open")})}async openDB(){return new Promise((e,t)=>{this.db&&e();let r=indexedDB.open(this.dbName);r.onsuccess=()=>{this.db=r.result,e()},r.onerror=()=>{t(r.error)},r.onupgradeneeded=()=>{this.db=r.result,this.db.createObjectStore(this.storeName)}})}async closeDB(){return new Promise((e,t)=>{this.db?(this.db.close(),this.db=null,e()):t("Database not open")})}async deleteDB(){return new Promise((e,t)=>{let r=indexedDB.deleteDatabase(this.dbName);r.onsuccess=()=>{e()},r.onerror=()=>{t(r.error)}})}isOpen(){return this.db!==null}};var h=class{constructor(e,t){this.changeCounter=0;this.lastSave=0;this.stopAutoSave=!1;this.register=new Map,this.indexedDB=new l("register","register"),this.settings=e,this.errorHandler=t}get(e){return this.register.get(e)}set(e,t){this.register.set(e,t),this.changeCounter++}delete(e){this.register.delete(e),this.changeCounter++}clear(){this.register.clear(),this.changeCounter++}has(e){return this.register.has(e)}keys(){return this.register.keys()}values(){return this.register.values()}entries(){return this.register.entries()}async loadRegister(){this.settings.debug&&console.log("Loading register"),this.indexedDB.isOpen()||await this.indexedDB.openDB();let e=await this.indexedDB.get("register");return e?(this.register.clear(),new Map(e).forEach((r,n)=>{this.register.set(n,r)}),this.settings.debug&&console.log("Register loaded: ",this.register),!0):(this.settings.debug&&console.log("No register found, using a fresh one"),!1)}async saveRegister(){if(this.lastSave!==this.changeCounter){this.indexedDB.isOpen()||await this.indexedDB.openDB(),this.settings.debug&&console.log("Saving register");var e=this.changeCounter;await this.indexedDB.set("register",this.register),this.lastSave=e,this.settings.debug&&console.log("Register saved: ",this.register)}}async clearRegister(){this.indexedDB.isOpen()||await this.indexedDB.openDB(),this.settings.debug&&console.log("Clearing register"),await this.indexedDB.delete("register"),this.settings.debug&&console.log("Register cleared")}async autoSaveRegister(){for(;!this.stopAutoSave;)await new Promise(e=>setTimeout(e,this.settings.register.autoSaveInterval)),await this.saveRegister()}};async function P(s,e){let t=s.Register.get(e);t!==void 0&&await _(s,e,t)}async function _(s,e,t){switch(s.MemoryMap.delete(e),t.location){case"l":w(e);break;case"s":E(e);break;case"i":s.IndexDBStorage.delete(e);break;default:s.ErrorHandler.error(new Error("Unknown storage location"));break}s.Register.delete(e)}async function O(s,e){let t=s.Register.get(e);if(t===void 0)return null;if(t.session!==void 0&&t.session!==s.SessionID||t.expires!==void 0&&t.expires<new Date().getTime())return await _(s,e,t),null;var r=s.MemoryMap.get(e);if(r===void 0){switch(t.location){case"l":r=y(e);break;case"s":r=x(e);break;case"i":r=await s.IndexDBStorage.get(e);break;default:r=null,s.ErrorHandler.error(new Error("Unknown storage location"));break}s.MemoryMap.set(e,r)}return r}var p=class{constructor(e){let t=new Map,r=new Date().getTime(),n=b(e||{},I),i=new d,o=new l("storage","storage"),a=new h(n,i),u=new m(n,i,o);this.instanceData={MemoryMap:t,Settings:n,Register:a,Queue:u,ErrorHandler:i,SessionID:r,IndexDBStorage:o}}async start(){var e=[];e.push(this.instanceData.IndexDBStorage.openDB()),e.push(this.instanceData.Queue.start());let t=this.instanceData.Register.loadRegister();e.push(t),t.then(()=>{this.instanceData.Register.autoSaveRegister()}),e.push(this.instanceData.Queue.init()),await Promise.all(e)}async setItem(e,t,r){return Q(this.instanceData,e,t,r)}async getItem(e){return O(this.instanceData,e)}async removeItem(e){P(this.instanceData,e)}async delete(){throw new Error("Not implemented")}clear(){this.instanceData.MemoryMap.clear()}async getMeta(e){throw new Error("Not implemented")}async getLength(){throw new Error("Not implemented")}async Keys(){throw new Error("Not implemented")}async hasItem(e){throw new Error("Not implemented")}setOptions(e,t){throw new Error("Not implemented")}on(e,t){throw new Error("Not implemented")}off(e,t){throw new Error("Not implemented")}offAll(e){throw new Error("Not implemented")}onError(e){this.instanceData.ErrorHandler.addListener(e)}offError(e){this.instanceData.ErrorHandler.removeListener(e)}offAllErrors(){this.instanceData.ErrorHandler.removeAllListener()}},fe=p;export{fe as default};
 Error("Not implemented")}async hasItem(e){throw new Error("Not implemented")}setOptions(e,t){throw new Error("Not implemented")}on(e,t){throw new Error("Not implemented")}off(e,t){throw new Error("Not implemented")}offAll(e){throw new Error("Not implemented")}onError(e){this.instanceData.ErrorHandler.addListener(e)}offError(e){this.instanceData.ErrorHandler.removeListener(e)}offAllErrors(){this.instanceData.ErrorHandler.removeAllListener()}},L=b;
