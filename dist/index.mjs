function b(r,e){var t,s,o,i;return{register:{autoSaveInterval:((t=r.register)==null?void 0:t.autoSaveInterval)||e.register.autoSaveInterval},webStorageThreshold:r.webStorageThreshold||e.webStorageThreshold,debug:r.debug||e.debug,shutter:{enabled:((s=r.shutter)==null?void 0:s.enabled)||e.shutter.enabled,interval:((o=r.shutter)==null?void 0:o.interval)||e.shutter.interval,timeout:((i=r.shutter)==null?void 0:i.timeout)||e.shutter.timeout}}}var I={register:{autoSaveInterval:1e3},debug:!1,webStorageThreshold:1e3,shutter:{enabled:!0,interval:100,timeout:150}};var u={_SIQ_sanityCheck_EntryOptions:{isEnabled:!0,expires:{isEnabled:!0,checkPositiv:!0,checkExpired:!0}}};function f(r){if(!(!u._SIQ_sanityCheck_EntryOptions.isEnabled||r===void 0)&&r.expires!==void 0&&u._SIQ_sanityCheck_EntryOptions.expires.isEnabled){if(typeof r.expires!="number")throw new Error("SanityC: The expires option must be a number");if(u._SIQ_sanityCheck_EntryOptions.expires.checkExpired&&r.expires<Date.now())throw new Error("SanityC: The expires option must be in the future");if(u._SIQ_sanityCheck_EntryOptions.expires.checkPositiv&&r.expires<0)throw new Error("SanityC: The expires option must be a positive number")}}function Q(r,e,t,s){return new Promise((o,i)=>{try{f(s),r.MemoryMap.set(e,t);var n="l";t==null||(t instanceof Object?n="i":typeof t=="string"&&t.length>r.Settings.webStorageThreshold&&(n="i")),s!==void 0&&s.sessional!==void 0&&s.sessional&&n==="l"&&(n="s");let c={key:e,location:n,value:t,callback:O=>{O||r.ErrorHandler.error(new Error("Failed to store the value")),o()}};r.Queue.addOrder(c);var a={location:n};s!==void 0&&(s.expires!==void 0&&(a.expires=s.expires),s.sessional!==void 0&&s.sessional&&(a.session=r.SessionID)),r.Register.set(e,a)}catch(c){r.ErrorHandler.error(c),o()}})}var g=class{constructor(){this.listeners=[]}addListener(e){this.listeners.push(e)}removeListener(e){this.listeners=this.listeners.filter(t=>t!==e)}removeAllListener(){this.listeners=[]}error(e){this.listeners.forEach(t=>t(e))}};function v(r,e){localStorage.setItem(r,JSON.stringify(e))}function y(r){let e=localStorage.getItem(r);return e?JSON.parse(e):null}function w(r){localStorage.removeItem(r)}function D(r,e){sessionStorage.setItem(r,JSON.stringify(e))}function x(r){let e=sessionStorage.getItem(r);return e?JSON.parse(e):null}function E(r){sessionStorage.removeItem(r)}var m=class{constructor(){this.items=[]}enqueue(e){this.items.push(e)}dequeue(){return this.items.shift()}clear(){this.items=[]}getAll(){return[...this.items]}length(){return this.items.length}isEmpty(){return this.items.length===0}};var S=class{constructor(e,t,s){this.blocked=!0;this.enabled=!1;this.running=!1;this.task=null;this.errOut=t,this.settings=e,this.indexedDB=s,this.queue=new m}async init(){}async processQueue(){try{for(this.running=!0;this.enabled;){let e=new Date().getTime(),t=new Date().getTime()+this.settings.shutter.interval,s=t+this.settings.shutter.timeout;this.settings.debug&&console.log("Async Queue: start:".concat(e,", end:").concat(t,", next:").concat(s)),this.process(t),await new Promise(o=>setTimeout(o,s-new Date().getTime()))}this.settings.debug&&console.log("Async Queue: Stopped by request.")}catch(e){this.errOut.error(e),this.settings.debug&&console.log("Async Queue: Stopped by error.")}finally{this.running=!1}}async process(e){var t,s,o;if(!(this.blocked||!this.enabled)&&!this.queue.isEmpty()&&(this.indexedDB===null&&await this.init(),!!((t=this.indexedDB)!=null&&t.isOpen()))){for(this.blocked=!0;new Date().getTime()<e;){let i=this.queue.dequeue();if(i==null)break;switch(i==null?void 0:i.location){case"i":await this.indexedDB.set(i.key,i.value);break;case"l":v(i.key,i.value);break;case"s":D(i.key,i.value);break;default:(s=i.callback)==null||s.call(i,!1),this.errOut.error(new Error("Invalid location"));break}(o=i.callback)==null||o.call(i,!0)}this.blocked=!1}}start(){if(this.running)return this.errOut.error(new Error("Async Queue is already running"));if(this.enabled)return this.errOut.error(new Error("Async Queue is already enabled"));if(this.task!==null)return this.errOut.error(new Error("Async Queue has already been initialized"));this.enabled=!0,this.blocked=!1,this.task=this.processQueue()}async stop(){if(!this.enabled)return this.errOut.error(new Error("Async Queue is not enabled"));if(this.task===null)return this.errOut.error(new Error("Async Queue has not been initialized"));this.enabled=!1,await this.task,this.blocked=!0,this.task=null}isRunning(){return this.running}addOrder(e){this.queue.enqueue(e)}async clear(){let e=this.running;e&&await this.stop(),this.queue.clear(),e&&this.start()}};var l=class{constructor(e,t){this.db=null;this.storeName=t,this.dbName="SIQ_"+e}async get(e){return new Promise((t,s)=>{if(this.db){let n=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).get(e);n.onsuccess=()=>{t(n.result)},n.onerror=()=>{s(n.error)}}else s("Database not open")})}async set(e,t){return new Promise((s,o)=>{if(this.db){let a=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).put(t,e);a.onsuccess=()=>{s()},a.onerror=()=>{o(a.error)}}else o("Database not open")})}async delete(e){return new Promise((t,s)=>{if(this.db){let n=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).delete(e);n.onsuccess=()=>{t()},n.onerror=()=>{s(n.error)}}else s("Database not open")})}async clear(){return new Promise((e,t)=>{if(this.db){let i=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).clear();i.onsuccess=()=>{e()},i.onerror=()=>{t(i.error)}}else t("Database not open")})}async keys(){return new Promise((e,t)=>{if(this.db){let i=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAllKeys();i.onsuccess=()=>{e(i.result)},i.onerror=()=>{t(i.error)}}else t("Database not open")})}async values(){return new Promise((e,t)=>{if(this.db){let i=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAll();i.onsuccess=()=>{e(i.result)},i.onerror=()=>{t(i.error)}}else t("Database not open")})}async entries(){return new Promise((e,t)=>{if(this.db){let i=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAll();i.onsuccess=()=>{e(i.result)},i.onerror=()=>{t(i.error)}}else t("Database not open")})}async openDB(){return new Promise((e,t)=>{this.db&&e();let s=indexedDB.open(this.dbName);s.onsuccess=()=>{this.db=s.result,e()},s.onerror=()=>{t(s.error)},s.onupgradeneeded=()=>{this.db=s.result,this.db.createObjectStore(this.storeName)}})}async closeDB(){return new Promise((e,t)=>{this.db?(this.db.close(),this.db=null,e()):t("Database not open")})}async deleteDB(){return new Promise((e,t)=>{let s=indexedDB.deleteDatabase(this.dbName);s.onsuccess=()=>{e()},s.onerror=()=>{t(s.error)}})}isOpen(){return this.db!==null}};var _=class{constructor(e,t){this.changeCounter=0;this.lastSave=0;this.stopAutoSave=!1;this.register=new Map,this.indexedDB=new l("register","register"),this.settings=e,this.errorHandler=t}get(e){return this.register.get(e)}set(e,t){this.register.set(e,t),this.changeCounter++}delete(e){this.register.delete(e),this.changeCounter++}clear(){this.register.clear(),this.changeCounter++}has(e){return this.register.has(e)}keys(){return this.register.keys()}values(){return this.register.values()}entries(){return this.register.entries()}async loadRegister(){this.settings.debug&&console.log("Loading register"),this.indexedDB.isOpen()||await this.indexedDB.openDB();let e=await this.indexedDB.get("register");return e?(this.register.clear(),new Map(e).forEach((s,o)=>{this.register.set(o,s)}),this.settings.debug&&console.log("Register loaded: ",this.register),!0):(this.settings.debug&&console.log("No register found, using a fresh one"),!1)}async saveRegister(){if(this.lastSave!==this.changeCounter){this.indexedDB.isOpen()||await this.indexedDB.openDB(),this.settings.debug&&console.log("Saving register");var e=this.changeCounter;await this.indexedDB.set("register",this.register),this.lastSave=e,this.settings.debug&&console.log("Register saved: ",this.register)}}async clearRegister(){this.indexedDB.isOpen()||await this.indexedDB.openDB(),this.settings.debug&&console.log("Clearing register"),await this.indexedDB.delete("register"),this.settings.debug&&console.log("Register cleared")}async autoSaveRegister(){for(;!this.stopAutoSave;)await new Promise(e=>setTimeout(e,this.settings.register.autoSaveInterval)),await this.saveRegister()}};async function P(r,e){let t=r.Register.get(e);t!==void 0&&await h(r,e,t)}async function h(r,e,t){switch(r.MemoryMap.delete(e),t.location){case"l":w(e);break;case"s":E(e);break;case"i":r.IndexDBStorage.delete(e);break;default:r.ErrorHandler.error(new Error("Unknown storage location"));break}r.Register.delete(e)}async function k(r,e){let t=r.Register.get(e);if(t===void 0)return null;if(t.session!==void 0&&t.session!==r.SessionID||t.expires!==void 0&&t.expires<new Date().getTime())return await h(r,e,t),null;var s=r.MemoryMap.get(e);if(s===void 0){switch(t.location){case"l":s=y(e);break;case"s":s=x(e);break;case"i":s=await r.IndexDBStorage.get(e);break;default:s=null,r.ErrorHandler.error(new Error("Unknown storage location"));break}r.MemoryMap.set(e,s)}return s}async function B(r){r.Queue.clear();let e=r.Register.entries(),t=r.IndexDBStorage.clear();for(let s of e){let o=s[0];switch(s[1].location){case"l":localStorage.removeItem(o);break;case"s":sessionStorage.removeItem(o);break;default:break}}r.Register.clear(),r.MemoryMap.clear(),await t}var p=class{constructor(e){let t=new Map,s=new Date().getTime(),o=b(e||{},I),i=new g,n=new l("storage","storage"),a=new _(o,i),c=new S(o,i,n);this.instanceData={MemoryMap:t,Settings:o,Register:a,Queue:c,ErrorHandler:i,SessionID:s,IndexDBStorage:n}}async start(){var e=[];e.push(this.instanceData.IndexDBStorage.openDB()),e.push(this.instanceData.Queue.start());let t=this.instanceData.Register.loadRegister();e.push(t),t.then(()=>{this.instanceData.Register.autoSaveRegister()}),e.push(this.instanceData.Queue.init()),await Promise.all(e)}async setItem(e,t,s){return Q(this.instanceData,e,t,s)}async getItem(e){return k(this.instanceData,e)}async removeItem(e){P(this.instanceData,e)}async delete(){B(this.instanceData)}clear(){this.instanceData.MemoryMap.clear()}async getMeta(e){throw new Error("Not implemented")}async getLength(){throw new Error("Not implemented")}async Keys(){throw new Error("Not implemented")}async hasItem(e){throw new Error("Not implemented")}setOptions(e,t){throw new Error("Not implemented")}on(e,t){throw new Error("Not implemented")}off(e,t){throw new Error("Not implemented")}offAll(e){throw new Error("Not implemented")}onError(e){this.instanceData.ErrorHandler.addListener(e)}offError(e){this.instanceData.ErrorHandler.removeListener(e)}offAllErrors(){this.instanceData.ErrorHandler.removeAllListener()}},we=p;export{we as default};
