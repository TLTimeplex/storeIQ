"use strict";var p=Object.defineProperty;var M=Object.getOwnPropertyDescriptor;var A=Object.getOwnPropertyNames;var T=Object.prototype.hasOwnProperty;var L=(r,e)=>{for(var t in e)p(r,t,{get:e[t],enumerable:!0})},q=(r,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of A(e))!T.call(r,n)&&n!==t&&p(r,n,{get:()=>e[n],enumerable:!(s=M(e,n))||s.enumerable});return r};var H=r=>q(p({},"__esModule",{value:!0}),r);var J={};L(J,{default:()=>z});module.exports=H(J);function f(r,e){var t,s,n,i;return{register:{autoSaveInterval:((t=r.register)==null?void 0:t.autoSaveInterval)||e.register.autoSaveInterval},webStorageThreshold:r.webStorageThreshold||e.webStorageThreshold,debug:r.debug||e.debug,shutter:{enabled:((s=r.shutter)==null?void 0:s.enabled)||e.shutter.enabled,interval:((n=r.shutter)==null?void 0:n.interval)||e.shutter.interval,timeout:((i=r.shutter)==null?void 0:i.timeout)||e.shutter.timeout}}}var Q={register:{autoSaveInterval:1e3},debug:!1,webStorageThreshold:1e3,shutter:{enabled:!0,interval:100,timeout:150}};var g=class{constructor(){this.listeners=[]}addListener(e){this.listeners.push(e)}removeListener(e){this.listeners=this.listeners.filter(t=>t!==e)}removeAllListener(){this.listeners=[]}error(e){this.listeners.forEach(t=>t(e))}};function v(r,e){localStorage.setItem(r,JSON.stringify(e))}function y(r){let e=localStorage.getItem(r);return e?JSON.parse(e):null}function D(r){localStorage.removeItem(r)}function w(r,e){sessionStorage.setItem(r,JSON.stringify(e))}function x(r){let e=sessionStorage.getItem(r);return e?JSON.parse(e):null}function E(r){sessionStorage.removeItem(r)}var d=class{constructor(){this.items=[]}enqueue(e){this.items.push(e)}dequeue(){return this.items.shift()}clear(){this.items=[]}getAll(){return[...this.items]}length(){return this.items.length}isEmpty(){return this.items.length===0}};var m=class{constructor(e,t,s){this.blocked=!0;this.enabled=!1;this.running=!1;this.task=null;this.errOut=t,this.settings=e,this.indexedDB=s,this.queue=new d}async init(){}async processQueue(){try{for(this.running=!0;this.enabled;){let e=new Date().getTime(),t=new Date().getTime()+this.settings.shutter.interval,s=t+this.settings.shutter.timeout;this.settings.debug&&console.log("Async Queue: start:".concat(e,", end:").concat(t,", next:").concat(s)),this.process(t),await new Promise(n=>setTimeout(n,s-new Date().getTime()))}this.settings.debug&&console.log("Async Queue: Stopped by request.")}catch(e){this.errOut.error(e),this.settings.debug&&console.log("Async Queue: Stopped by error.")}finally{this.running=!1}}async process(e){var t,s,n;if(!(this.blocked||!this.enabled)&&!this.queue.isEmpty()&&(this.indexedDB===null&&await this.init(),!!((t=this.indexedDB)!=null&&t.isOpen()))){for(this.blocked=!0;new Date().getTime()<e;){let i=this.queue.dequeue();if(i==null)break;switch(i==null?void 0:i.location){case"i":await this.indexedDB.set(i.key,i.value);break;case"l":v(i.key,i.value);break;case"s":w(i.key,i.value);break;default:(s=i.callback)==null||s.call(i,!1),this.errOut.error(new Error("Invalid location"));break}(n=i.callback)==null||n.call(i,!0)}this.blocked=!1}}start(){if(this.running)return this.errOut.error(new Error("Async Queue is already running"));if(this.enabled)return this.errOut.error(new Error("Async Queue is already enabled"));if(this.task!==null)return this.errOut.error(new Error("Async Queue has already been initialized"));this.enabled=!0,this.blocked=!1,this.task=this.processQueue()}async stop(){if(!this.enabled)return this.errOut.error(new Error("Async Queue is not enabled"));if(this.task===null)return this.errOut.error(new Error("Async Queue has not been initialized"));this.enabled=!1,await this.task,this.blocked=!0,this.task=null}isRunning(){return this.running}addOrder(e){this.queue.enqueue(e)}async clear(){let e=this.running;e&&await this.stop(),this.queue.clear(),e&&this.start()}};var l=class{constructor(e,t){this.db=null;this.storeName=t,this.dbName="SIQ_"+e}async get(e){return new Promise((t,s)=>{if(this.db){let o=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).get(e);o.onsuccess=()=>{t(o.result)},o.onerror=()=>{s(o.error)}}else s("Database not open")})}async set(e,t){return new Promise((s,n)=>{if(this.db){let a=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).put(t,e);a.onsuccess=()=>{s()},a.onerror=()=>{n(a.error)}}else n("Database not open")})}async delete(e){return new Promise((t,s)=>{if(this.db){let o=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).delete(e);o.onsuccess=()=>{t()},o.onerror=()=>{s(o.error)}}else s("Database not open")})}async clear(){return new Promise((e,t)=>{if(this.db){let i=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).clear();i.onsuccess=()=>{e()},i.onerror=()=>{t(i.error)}}else t("Database not open")})}async keys(){return new Promise((e,t)=>{if(this.db){let i=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAllKeys();i.onsuccess=()=>{e(i.result)},i.onerror=()=>{t(i.error)}}else t("Database not open")})}async values(){return new Promise((e,t)=>{if(this.db){let i=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAll();i.onsuccess=()=>{e(i.result)},i.onerror=()=>{t(i.error)}}else t("Database not open")})}async entries(){return new Promise((e,t)=>{if(this.db){let i=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).getAll();i.onsuccess=()=>{e(i.result)},i.onerror=()=>{t(i.error)}}else t("Database not open")})}async openDB(){return new Promise((e,t)=>{this.db&&e();let s=indexedDB.open(this.dbName);s.onsuccess=()=>{this.db=s.result,e()},s.onerror=()=>{t(s.error)},s.onupgradeneeded=()=>{this.db=s.result,this.db.createObjectStore(this.storeName)}})}async closeDB(){return new Promise((e,t)=>{this.db?(this.db.close(),this.db=null,e()):t("Database not open")})}async deleteDB(){return new Promise((e,t)=>{let s=indexedDB.deleteDatabase(this.dbName);s.onsuccess=()=>{e()},s.onerror=()=>{t(s.error)}})}isOpen(){return this.db!==null}};var _=class{constructor(e,t){this.changeCounter=0;this.lastSave=0;this.stopAutoSave=!1;this.register=new Map,this.indexedDB=new l("register","register"),this.settings=e,this.errorHandler=t}get(e){return this.register.get(e)}set(e,t){this.register.set(e,t),this.changeCounter++}delete(e){this.register.delete(e),this.changeCounter++}clear(){this.register.clear(),this.changeCounter++}has(e){return this.register.has(e)}keys(){return this.register.keys()}values(){return this.register.values()}entries(){return this.register.entries()}size(){return this.register.size}async loadRegister(){this.settings.debug&&console.log("Loading register"),this.indexedDB.isOpen()||await this.indexedDB.openDB();let e=await this.indexedDB.get("register");return e?(this.register.clear(),new Map(e).forEach((s,n)=>{this.register.set(n,s)}),this.settings.debug&&console.log("Register loaded: ",this.register),!0):(this.settings.debug&&console.log("No register found, using a fresh one"),!1)}async saveRegister(){if(this.lastSave!==this.changeCounter){this.indexedDB.isOpen()||await this.indexedDB.openDB(),this.settings.debug&&console.log("Saving register");var e=this.changeCounter;await this.indexedDB.set("register",this.register),this.lastSave=e,this.settings.debug&&console.log("Register saved: ",this.register)}}async clearRegister(){this.indexedDB.isOpen()||await this.indexedDB.openDB(),this.settings.debug&&console.log("Clearing register"),await this.indexedDB.delete("register"),this.settings.debug&&console.log("Register cleared")}async autoSaveRegister(){for(;!this.stopAutoSave;)await new Promise(e=>setTimeout(e,this.settings.register.autoSaveInterval)),await this.saveRegister()}};var u={_SIQ_sanityCheck_EntryOptions:{isEnabled:!0,expires:{isEnabled:!0,checkPositiv:!0,checkExpired:!0}}};function h(r){if(!(!u._SIQ_sanityCheck_EntryOptions.isEnabled||r===void 0)&&r.expires!==void 0&&u._SIQ_sanityCheck_EntryOptions.expires.isEnabled){if(typeof r.expires!="number")throw new Error("SanityC: The expires option must be a number");if(u._SIQ_sanityCheck_EntryOptions.expires.checkExpired&&r.expires<Date.now())throw new Error("SanityC: The expires option must be in the future");if(u._SIQ_sanityCheck_EntryOptions.expires.checkPositiv&&r.expires<0)throw new Error("SanityC: The expires option must be a positive number")}}function O(r,e,t,s){return new Promise((n,i)=>{try{h(s),r.MemoryMap.set(e,t);var o="l";t==null||(t instanceof Object?o="i":typeof t=="string"&&t.length>r.Settings.webStorageThreshold&&(o="i")),s!==void 0&&s.sessional!==void 0&&s.sessional&&o==="l"&&(o="s");let c={key:e,location:o,value:t,callback:C=>{C||r.ErrorHandler.error(new Error("Failed to store the value")),n()}};r.Queue.addOrder(c);var a={location:o};s!==void 0&&(s.expires!==void 0&&(a.expires=s.expires),s.sessional!==void 0&&s.sessional&&(a.session=r.SessionID)),r.Register.set(e,a)}catch(c){r.ErrorHandler.error(c),n()}})}async function P(r,e){let t=r.Register.get(e);t!==void 0&&await b(r,e,t)}async function b(r,e,t){switch(r.MemoryMap.delete(e),t.location){case"l":D(e);break;case"s":E(e);break;case"i":r.IndexDBStorage.delete(e);break;default:r.ErrorHandler.error(new Error("Unknown storage location"));break}r.Register.delete(e)}async function k(r,e){let t=r.Register.get(e);if(t===void 0)return null;if(t.session!==void 0&&t.session!==r.SessionID||t.expires!==void 0&&t.expires<new Date().getTime())return await b(r,e,t),null;var s=r.MemoryMap.get(e);if(s===void 0){switch(t.location){case"l":s=y(e);break;case"s":s=x(e);break;case"i":s=await r.IndexDBStorage.get(e);break;default:s=null,r.ErrorHandler.error(new Error("Unknown storage location"));break}r.MemoryMap.set(e,s)}return s}async function B(r){r.Queue.clear();let e=r.Register.entries(),t=r.IndexDBStorage.clear();for(let s of e){let n=s[0];switch(s[1].location){case"l":localStorage.removeItem(n);break;case"s":sessionStorage.removeItem(n);break;default:break}}r.Register.clear(),r.MemoryMap.clear(),await t}async function R(r,e,t){try{var s=r.Register.get(e);if(!s)throw new Error("No such key");h(t),t.expires&&(s.expires=t.expires),t.sessional&&(s.session=r.SessionID),r.Register.set(e,s)}catch(n){return r.ErrorHandler.error(n)}}function N(){var r=sessionStorage.getItem("sessionID");if(r!==null)return parseInt(r);var e=new Date().getTime();return sessionStorage.setItem("sessionID",e.toString()),e}var I=class{constructor(e){let t=new Map,s=N(),n=f(e||{},Q),i=new g,o=new l("storage","storage"),a=new _(n,i),c=new m(n,i,o);this.instanceData={MemoryMap:t,Settings:n,Register:a,Queue:c,ErrorHandler:i,SessionID:s,IndexDBStorage:o}}async start(){var e=[];e.push(this.instanceData.IndexDBStorage.openDB()),e.push(this.instanceData.Queue.start());let t=this.instanceData.Register.loadRegister();e.push(t),t.then(()=>{this.instanceData.Register.autoSaveRegister()}),e.push(this.instanceData.Queue.init()),await Promise.all(e)}async setItem(e,t,s){return O(this.instanceData,e,t,s)}async getItem(e){return k(this.instanceData,e)}async removeItem(e){P(this.instanceData,e)}async delete(){B(this.instanceData)}clear(){this.instanceData.MemoryMap.clear()}async getMeta(e){throw new Error("Not implemented")}async getLength(){return this.instanceData.Register.size()}async Keys(){return Array.from(this.instanceData.Register.keys())}async hasItem(e){return this.instanceData.Register.has(e)}setOptions(e,t){R(this.instanceData,e,t)}on(e,t){throw new Error("Not implemented")}off(e,t){throw new Error("Not implemented")}offAll(e){throw new Error("Not implemented")}onError(e){this.instanceData.ErrorHandler.addListener(e)}offError(e){this.instanceData.ErrorHandler.removeListener(e)}offAllErrors(){this.instanceData.ErrorHandler.removeAllListener()}},z=I;
